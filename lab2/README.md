1. 数据结构与初始化
首先，我们定义了几种基本数据结构：

哈夫曼树节点 (Node):
结构：每个节点包含一个字符 character（如果是内部节点则为空字符），一个频率 frequency，以及指向左右子节点的指针 left 和 right。
用途：哈夫曼树中的每个节点要么是叶子节点（表示一个字符），要么是内部节点（用于合并两个子树）。
最小堆 (MinHeap):
结构：最小堆用来存储 Node 指针，它实现了哈夫曼树的构建。通过最小堆（优先队列）来合并频率最小的两个节点，直到合并成一棵树。
操作：
createMinHeap()：创建一个空的最小堆。
insertMinHeap()：将一个节点插入最小堆并保持堆的性质。
extractMin()：从最小堆中取出频率最小的节点，并重新调整堆。
2. 哈夫曼树的构建
buildHuffmanTree()：该函数接收字符集和对应的频率，通过构建最小堆来创建哈夫曼树。
初始化最小堆：将每个字符和频率插入最小堆。
合并节点：从堆中提取出频率最小的两个节点（叶子节点），创建一个新的内部节点，将这两个节点作为它的左右子节点。将新的内部节点插入堆中。重复此过程，直到堆中只剩一个节点，那个节点即为哈夫曼树的根节点。
3. 生成哈夫曼编码
generateHuffmanCodes()：该函数递归遍历哈夫曼树，并为每个字符生成哈夫曼编码。
对于每个叶子节点（表示字符），我们将从根节点到该字符的路径编码（'0' 表示左子树，'1' 表示右子树）。
编码通过递归过程传递。递归终止条件是到达叶子节点时，将路径存储在全局数组 huffmanCodes 中。
4. 编码过程
encode()：将给定的输入文本转换为哈夫曼编码。
遍历每个字符，找到它的哈夫曼编码，并将编码写入输出文件 CodeFile。
5. 译码过程
decode()：根据哈夫曼树对编码进行译码。
从哈夫曼树的根节点开始，遍历编码串。遇到 0 就向左子树走，遇到 1 就向右子树走。
当到达叶子节点时，输出该节点的字符，并从根节点重新开始，继续译码下一个字符。
6. 哈夫曼树打印
printTree()：该函数用于直观地打印哈夫曼树的结构。
通过递归，先打印右子树（更深的层次），然后打印当前节点，再打印左子树（较浅的层次）。每个节点都会显示字符及其频率。递归过程中通过 indent 参数控制缩进，帮助显示树的层次结构。
7. 文件操作
hfmTree：保存哈夫曼树的结构。通过 printTree() 函数打印树结构，可以将其写入文件中，方便后续的解码使用。
CodeFile：保存编码后的结果。encode() 函数将文本编码并写入该文件。
TextFile：保存译码后的结果。decode() 函数从编码文件中读取编码，并译码恢复原始文本，写入此文件。
CodePrin：以每行 50 个字符的格式显示编码文件内容，同时将其写入文件。通过 fgetc() 逐字符读取编码文件，并按行显示。
8. 主程序
主程序的流程大致如下：

初始化输入：接收字符数 n，然后接收每个字符及其频率。
构建哈夫曼树：调用 buildHuffmanTree() 函数构建哈夫曼树。
生成哈夫曼编码：调用 generateHuffmanCodes() 函数为每个字符生成编码。
编码：使用 encode() 函数将输入文本编码并存储到 CodeFile 文件中。
译码：使用 decode() 函数将编码文件中的内容译码并保存到 TextFile 文件中。
打印输出：打印编码文件，并将哈夫曼树结构输出到文件中。
9. 编码和译码的完整流程
编码：通过遍历每个字符，使用哈夫曼编码表，将字符转化为哈夫曼编码，输出到文件。
译码：读取编码文件，从根节点开始，根据编码逐步向左或向右移动，直到恢复出原始字符。